1.  What’s stdint.h?

stdint.h is a header file containing declarations of fixed-width
integers. Width refers to the n of bits the data type consumes.
E.g. uint32_t, unsigned int 32 bits (4 bytes) wide or long.
There are other types too: minimum width, fastest minimum,
pointer-holding (64 or 32 bit) and max-width int data types.

2.  What’s the point of using uint8_t, uint32_t,
    int32_t, and uint16_t in a program?

Firstly, it specifies what kind of number one will store:
small vs big, postive only vs all ints.
Secondly, portability. Basic C ints are seen insufficient because
the actual sizes are implementation dependent (compiler, os, hardware).
Ergo, stdint.h types make sure that the same data type has the same width
across systems.

3.  How many bytes is a BYTE, a DWORD,
    a LONG, and a WORD, respectively?

BYTE    = uint8_t   = 1 byte    = 8 bit
DWORD   = uint32_t  = 4 byte    = 32 bit
LONG    = int32_t   = 4 byte    = 32 bit
WORD    = uin16_t   = 2 byte    = 16 bit

4.  What (in ASCII, decimal, or hexadecimal) must the first two bytes
    of any BMP file be? Leading bytes used to identify file formats
    (with high probability) are generally called "magic numbers."

~/workspace/pset4/whodunit/ (master) $ xxd -c 24 -g 3 smiley.bmp                 
0000000: 424df6 000000 000000 003600 000028 000000 080000 00f8ff  BM........6...(.........
0000018: ffff01 001800 000000 00c000 000012 0b0000 120b00 000000  ........................
0000030: 000000 000000 ffffff ffffff 0000ff 0000ff 0000ff 0000ff  ........................
0000048: ffffff ffffff ffffff 0000ff ffffff ffffff ffffff ffffff  ........................
0000060: 0000ff ffffff 0000ff ffffff 0000ff ffffff ffffff 0000ff  ........................
0000078: ffffff 0000ff 0000ff ffffff ffffff ffffff ffffff ffffff  ........................
0000090: ffffff 0000ff 0000ff ffffff 0000ff ffffff ffffff 0000ff  ........................
00000a8: ffffff 0000ff 0000ff ffffff ffffff 0000ff 0000ff ffffff  ........................
00000c0: ffffff 0000ff ffffff 0000ff ffffff ffffff ffffff ffffff  ........................
00000d8: 0000ff ffffff ffffff ffffff 0000ff 0000ff 0000ff 0000ff  ........................
00000f0: ffffff ffffff                                            ......

So the first two bytes of a .bmp file are 424d. Lets break it down:

hex:        0x42     0x4d
binary:     01000010 01001101
decimal:    66       77
ASCII:      B        M

Makes sense, because the rightmost column of xxd output supports us.

5.  What’s the difference between bfSize and biSize?

bfSize = The size, in bytes, of the bitmap file
= two headers + image = 54 + x bytes
biSize = the size of BITMAPINFOHEADER = 40 byte.

6.  What does it mean if biHeight is negative?

biHeight = height of the image in pixels
If negative, the image is a top-down DIB (device-independent bitmap)
and the origin is upper-left corner. Else, the image is a
bottom-up DIB with origin in the lower-left corner.

7.  What field in BITMAPINFOHEADER specifies the
    BMP’s color depth (i.e., bits per pixel)?

biBitCount sets the n of bits per pixel
eg. 24-bit BMP: triplets of 8 bits for blue, green, red
with 3 byte per pixel (24 / 8 = 3)

8.  Why might fopen return NULL in lines 24 and 32 of copy.c?

fopen(path, mode) opens file at path and returns pointer to file.
If it cannot open the file (wrong path, no permissions, ...)
a NULL pointer is returned.

9.  Why is the third argument to fread always 1 in our code?

size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)
The third argument nmemb denotes how many elements of size bytes
should be read from stream and stored at location pointed to by ptr.

fread(&bf, sizeof(BITMAPFILEHEADER), 1, inptr)
Read 1 times sizeof(BITMAPFILEHEADER) bytes from inptr and put
the data into memory at address of bf.

It is always one, because we only want to read and store
the headers once. No need for several headers of the same type.


10. What value does line 65 of copy.c
    assign to padding if bi.biWidth is 3?

biWidth = width of image in pixels.
padding = (4 - (3 * 3 byte) % 4) % 4 = 1 byte

11. What does fseek do?

int fseek(FILE *stream, long offset, int whence)
Moves file position indicator for stream by offset bytes
relative from whence (SEEK_SET, SEEK_CUR, SEEK_END).

12. What is SEEK_CUR?

Move file position indicator relative ...
SEEK_SET: from start of file
SEEK_CUR: from current position
SEEK_END: from end of file